import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.awt.Color;
import java.awt.Point;

/**
The map generated by robot sensors. This was deemed necessary because of the
redundancy of certain bits of generation logic.

	<h1>Revision History:</h1>
	<ul>
		<li>November 06, 2008, Benjamin Gauronskas</li>
		<ul>
			<li>Added constants.</li>
			<li>Added method used for sending points and colors over the
					network.</li>
		</ul>
		<li>November 05, 2008, Benjamin Gauronskas</li>
		<ul>
			<li>Created file.</li>
		</ul>

	</ul>
<p>
Credits to http://www.exampledepot.com/egs/javax.imageio/Graphic2File.html
</p>
<p>
Note to self: It is reccomended to use Graphics.dispose() to de-allocate memory
Since several graphics are not being created, I believe it unnecessary.
</p>
@version 0.1
@author Benjamin Gauronskas
*/
public class Map
{


	/**
	This is the walls of the map.
	*/
	public Graphics2D wallMap;

	/**
	This is the walls of the map.
	*/
	public BufferedImage wallMapImage;

	/**
	This is the temperature map.
	*/
	public Graphics2D tempMap;

	/**
	This is the temperature map.
	*/
	public BufferedImage tempMapImage;

	/**
	This is the map depicting traversal.
	*/
	public Graphics2D traverseMap;

	/**
	This is the map depicting traversal.
	*/
	public BufferedImage traverseMapImage;

	/**
	The code for mapping on the wallMap.
	*/
	public static final byte WALL_MAP = 0x00;

	/**
	The code for mapping on the temperature map.
	*/
	public static final byte TEMP_MAP = 0x01;

	/**
	The code for mapping on the traversal map.
	*/
	public static final byte TRAV_MAP = 0x02;

	/**
	The amount of pixels per inch.
	*/
	public static final int PPI = 2;

	/**
	The decided radius for the circle in pixels.
	*/
	public static final int HEAT_RADIUS = 30*PPI;

	/**
	The amount of pixels per foot.
	*/
	public static final int PPF = PPI*12;


	/**
	The "feet" across that the map will be.
	*/
	public static final int MAP_FEET_X = 65;

	/**
	The "feet" tall that the map will be.
	*/
	public static final int MAP_FEET_Y = 40;

	/**
	The pixels across that the map will be.
	*/
	public static final int MAP_PIXELS_X = MAP_FEET_X*PPF;

	/**
	The pixels tall that the map will be.
	*/
	public static final int MAP_PIXELS_Y = MAP_FEET_Y*PPF;

	/**
	North in the coordinate system.
	*/
	public static final double NORTH = (Math.PI*3)/2;

	/**
	The color of mapped walls.
	*/
	public static final Color WALL_COLOR = Color.blue;

	/**
	The color of the path.
	*/
	public static final Color PATH_COLOR = Color.green;

	/**
	The color of impassable heat
	*/
	public static final Color HOT_COLOR = Color.red;


	/**
	Constructor for the map object.

	@author		Benjamin Gauronskas
	*/
	public Map()
	{
		wallMapImage = new BufferedImage(MAP_PIXELS_X, MAP_PIXELS_Y, BufferedImage.TYPE_INT_ARGB);
		tempMapImage = new BufferedImage(MAP_PIXELS_X, MAP_PIXELS_Y, BufferedImage.TYPE_INT_ARGB);
		traverseMapImage = new BufferedImage(MAP_PIXELS_X, MAP_PIXELS_Y, BufferedImage.TYPE_INT_ARGB);
		

		wallMap =	wallMapImage.createGraphics();
		tempMap =	tempMapImage.createGraphics();
		traverseMap =	traverseMapImage.createGraphics();
	}

    /**
	Adds a heat plot.
	@param	temp	The temperature to plot.
	@param	point	The point the reading was made at.
    */
	public void plotHeat(byte temp, Point point){
		Color tempColor = new Color(temp, 0, 0);
		tempMap.setColor(tempColor);
		tempMap.fillOval((int)point.getX(), (int)point.getY(), HEAT_RADIUS, HEAT_RADIUS);
	}


    /**
	Adds a line segment to the specified map.
	@param	beginning	The start of a line segment to draw.
	@param	end	The end of that line segment.
	@param	target	The target map specified by a given byte constant.
	@author		Benjamin Gauronskas
    */
	public void plotSegment(Point beginning, Point end, byte target){
		Graphics2D pointer;
		Color color;
		switch (target) {
			case WALL_MAP: pointer = wallMap; color = WALL_COLOR; break;
			case TEMP_MAP: pointer = tempMap; color = HOT_COLOR; break;
			case TRAV_MAP: pointer = traverseMap; color = PATH_COLOR; break;
			default: System.out.println("OH NO. PLOT SEGMENT BROKE"); pointer=null; color=null; break;
		}
		if(pointer != null){
			pointer.setColor(color);
			pointer.drawLine(		(int)beginning.getX(), (int)beginning.getY(), 
									(int)end.getX(), (int)end.getY());
		}
	}

	/**
	 *	Returns a small section of the wall map determined by parameters passed to it.
	 *	@param	x	the leftmost x coordinate of the section.
	 *	@param 	y	the bottomost y coordinate
	 *	@param	displace_x	The width of the image
	 *	@param	displace_y	the height of the new image

	 *	@return	Will return a smaller than expected subimage if parts are out of bounds.
	 *	@author Benjamin Gauronskas
	 */
	public int[] getWallMapSection(int x, int y, int displace_x, int displace_y, int[] target){

		System.out.println("!@#$\tin getWallMapSection.\n\tx = " + x +
		"\n\ty= " + y + "\n\tdisplace_x = " + displace_x + "\n\tdisplace_y = " + displace_y);
		if (y+displace_y > MAP_PIXELS_Y)
			displace_y = MAP_PIXELS_Y;
		if(x+displace_x > MAP_PIXELS_X)
			displace_x = MAP_PIXELS_X;
		if(x <0)
			x=0;
		if(y < 0)
			y = 0;
		System.out.println("!@#$\tAfter error checking.\n\tx = " + x +
		"\n\ty= " + y + "\n\tdisplace_x = " + displace_x + "\n\tdisplace_y = " + displace_y);
		System.out.println("!@#$\tExiting Map.getWallMapSection");
		return wallMapImage.getRGB(x, y, Math.abs(displace_x), Math.abs(displace_y), target, 0, 1);

	}


    /**
	Adds a point to the map.
	@param	point	The point to draw.
	@param	color	The color to draw it in.
	@author		Benjamin Gauronskas
    */
    public void updateMapPoint(Point point, Color color) {

		//setRGB(point.getX(), point.getY(), color.getRGB());
		
    }


}
